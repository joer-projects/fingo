// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: queries.sql

package accounting_db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addTransaction = `-- name: AddTransaction :exec
INSERT INTO accounting_transaction(
  id, 
  project_id, 
  accounting_transaction_type_id,
  memo, 
  posting_date, 
  created_by, 
  created_at
  ) VALUES ($1, $2, $3, $4, $5, $6, $7)
`

type AddTransactionParams struct {
	ID                          string
	ProjectID                   pgtype.Text
	AccountingTransactionTypeID int32
	Memo                        pgtype.Text
	PostingDate                 pgtype.Timestamptz
	CreatedBy                   string
	CreatedAt                   pgtype.Timestamptz
}

func (q *Queries) AddTransaction(ctx context.Context, arg AddTransactionParams) error {
	_, err := q.db.Exec(ctx, addTransaction,
		arg.ID,
		arg.ProjectID,
		arg.AccountingTransactionTypeID,
		arg.Memo,
		arg.PostingDate,
		arg.CreatedBy,
		arg.CreatedAt,
	)
	return err
}

const getTransaction = `-- name: GetTransaction :one
SELECT id, project_id, accounting_transaction_type_id, memo, posting_date, updated_by, updated_at, created_by, created_at FROM accounting_transaction WHERE id = $1
`

func (q *Queries) GetTransaction(ctx context.Context, id string) (AccountingTransaction, error) {
	row := q.db.QueryRow(ctx, getTransaction, id)
	var i AccountingTransaction
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.AccountingTransactionTypeID,
		&i.Memo,
		&i.PostingDate,
		&i.UpdatedBy,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.CreatedAt,
	)
	return i, err
}

const getTransactions = `-- name: GetTransactions :many
SELECT id, project_id, accounting_transaction_type_id, memo, posting_date, updated_by, updated_at, created_by, created_at FROM accounting_transaction
`

func (q *Queries) GetTransactions(ctx context.Context) ([]AccountingTransaction, error) {
	rows, err := q.db.Query(ctx, getTransactions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AccountingTransaction
	for rows.Next() {
		var i AccountingTransaction
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.AccountingTransactionTypeID,
			&i.Memo,
			&i.PostingDate,
			&i.UpdatedBy,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const saveTransaction = `-- name: SaveTransaction :exec
INSERT INTO accounting_transaction(
  id,
  project_id,
  accounting_transaction_type_id,
  memo,
  posting_date,
  updated_by,
  updated_at,
  created_by,
  created_at
) VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9)
`

type SaveTransactionParams struct {
	ID                          string
	ProjectID                   pgtype.Text
	AccountingTransactionTypeID int32
	Memo                        pgtype.Text
	PostingDate                 pgtype.Timestamptz
	UpdatedBy                   pgtype.Text
	UpdatedAt                   pgtype.Timestamptz
	CreatedBy                   string
	CreatedAt                   pgtype.Timestamptz
}

func (q *Queries) SaveTransaction(ctx context.Context, arg SaveTransactionParams) error {
	_, err := q.db.Exec(ctx, saveTransaction,
		arg.ID,
		arg.ProjectID,
		arg.AccountingTransactionTypeID,
		arg.Memo,
		arg.PostingDate,
		arg.UpdatedBy,
		arg.UpdatedAt,
		arg.CreatedBy,
		arg.CreatedAt,
	)
	return err
}

const seedLedgerAccount = `-- name: SeedLedgerAccount :exec
INSERT INTO ledger_account(
  ledger_account_id, 
  description,
  account_code,
  tax_code,
  name,
  ledger_account_class_id,
  ledger_account_type_id,
  ledger_account_sub_type_id,
  ledger_account_level,
  ledger_account_parent_id,
  updated_by,
  updated_at,
  created_by,
  created_at
  ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)
`

type SeedLedgerAccountParams struct {
	LedgerAccountID        string
	Description            pgtype.Text
	AccountCode            pgtype.Text
	TaxCode                pgtype.Text
	Name                   string
	LedgerAccountClassID   int32
	LedgerAccountTypeID    int32
	LedgerAccountSubTypeID int32
	LedgerAccountLevel     int32
	LedgerAccountParentID  pgtype.Text
	UpdatedBy              pgtype.Text
	UpdatedAt              pgtype.Timestamptz
	CreatedBy              string
	CreatedAt              pgtype.Timestamptz
}

func (q *Queries) SeedLedgerAccount(ctx context.Context, arg SeedLedgerAccountParams) error {
	_, err := q.db.Exec(ctx, seedLedgerAccount,
		arg.LedgerAccountID,
		arg.Description,
		arg.AccountCode,
		arg.TaxCode,
		arg.Name,
		arg.LedgerAccountClassID,
		arg.LedgerAccountTypeID,
		arg.LedgerAccountSubTypeID,
		arg.LedgerAccountLevel,
		arg.LedgerAccountParentID,
		arg.UpdatedBy,
		arg.UpdatedAt,
		arg.CreatedBy,
		arg.CreatedAt,
	)
	return err
}

const seedLedgerAccountClass = `-- name: SeedLedgerAccountClass :exec
INSERT INTO ledger_account_class(ledger_account_class_id, name) VALUES ($1, $2)
`

type SeedLedgerAccountClassParams struct {
	LedgerAccountClassID int32
	Name                 string
}

func (q *Queries) SeedLedgerAccountClass(ctx context.Context, arg SeedLedgerAccountClassParams) error {
	_, err := q.db.Exec(ctx, seedLedgerAccountClass, arg.LedgerAccountClassID, arg.Name)
	return err
}

const seedLedgerAccountSubType = `-- name: SeedLedgerAccountSubType :exec
INSERT INTO ledger_account_sub_type(ledger_account_sub_type_id, name) VALUES ($1, $2)
`

type SeedLedgerAccountSubTypeParams struct {
	LedgerAccountSubTypeID int32
	Name                   string
}

func (q *Queries) SeedLedgerAccountSubType(ctx context.Context, arg SeedLedgerAccountSubTypeParams) error {
	_, err := q.db.Exec(ctx, seedLedgerAccountSubType, arg.LedgerAccountSubTypeID, arg.Name)
	return err
}

const seedLedgerAccountType = `-- name: SeedLedgerAccountType :exec
INSERT INTO ledger_account_type(ledger_account_type_id, name) VALUES ($1, $2)
`

type SeedLedgerAccountTypeParams struct {
	LedgerAccountTypeID int32
	Name                string
}

func (q *Queries) SeedLedgerAccountType(ctx context.Context, arg SeedLedgerAccountTypeParams) error {
	_, err := q.db.Exec(ctx, seedLedgerAccountType, arg.LedgerAccountTypeID, arg.Name)
	return err
}

const seedTransactionType = `-- name: SeedTransactionType :exec

INSERT INTO accounting_transaction_type(accounting_transaction_type_id, name) VALUES ($1, $2)
`

type SeedTransactionTypeParams struct {
	AccountingTransactionTypeID int32
	Name                        string
}

// pgFormatter-ignore
func (q *Queries) SeedTransactionType(ctx context.Context, arg SeedTransactionTypeParams) error {
	_, err := q.db.Exec(ctx, seedTransactionType, arg.AccountingTransactionTypeID, arg.Name)
	return err
}
